    Cucumber Backgrounder
    Or: How I Lerned to Stop Worrying and Start Behaving
    
    Введение

Cucumber это инструмент, который осуществляет проектирование рабочего процесса на основе поведения(Behaviour Driven Design (BDD) workflow). Этот документ имеет дело в основном первоначальную настройку и первое использование Cucumber-Rails и Cucumber Rubygems. На это в качестве основы потребуется инфраструктура вэб приложения Ruby on Rails (RoR). Подробное обсуждение BDD, TDD и Panic Driven Development может быть найдене повсюдю. Конечно, существуют некоторые скептики по этой полной Agile материалу, но если вы читаете это, то вы возможно не являетесь одним из них.

Вы убедитесь что некоторое знакомство с Ruby языком является полезным и несколько меньше, знакомство с RoR инфраструктурой. Эта


    Что такое Features и Scenarious?

Feature можно представить как неделимую единицу функциональной возможности встроенной в проект, к которому она принадлежит. Например, задача аудентификации и реакция пользовательского интерфейса как правило считается функциональной возможностью, в то время как полная система идентификации обязательно заключает в себе массу функциональных возможностей. Отдельная функциональная возможность (Feature) как правило содержится в своем собственном файле (оканчивающийся на .feature). Каждая функциональная возможность (Feature) как правило определяет (детализирует) хотя бы несколько сценариев (Scenarious).
    
Scenario является блоком утверждений внутри feature файла, который описывает некоторое желаемое или не реккомендуемое(запрещенное) поведение. Для требуемых ответов сценарий (scenario) может проверять предоставляемые
интерфейсом логина поля ввода, неудачные попытки логируются или же о них сообщается пользователю, id которого является заблокированным после нескольких неудачных попыток и так далее. Каждый сценарий выполняет код реализации чтобы удостовериться в том, что для каждого предполагаемого условия в самом деле происходит ожидаемое поведение. Напомним что эти сценарии указывают Что (What) и следует избегать ответа на вопрос: Как?(How)

Каждый сценарий состоит из трех классов утверждений, Given, When и Then, которые эффективно разделяют каждый сценарий на три стадии(stage). Каждый стадия сценария состоит из одного или более утверждений, которые используются чтобы соответствовать, чтобы проверять step definitions. Общепринятым оформлением является :


    Feature: Some terse yet descriptive text of what is desired (Отчасти краткий, но описательный текст того, что желательно
    
    In order that some business value is realized ( Для того чтобы реализовать бизнес требование)
    An actor with some explicit system role ( действующему лицу с некотороя явной системной ролью)
    Should obtain some beneficial outcome which furthers the goal ( следует получить некоторые полезные результаты, которые способствуют достижению цели )
    To Increase Revenue | Reduce Costs | Protect Revenue (pick one) ( для увеличения доходов | снижение издержек | защиты доходов (выберите один) )
    
    Scenario: Some determinable business situation
        Given some condition to meet
            And some other condition to meet
        When some action by the actor
            And some other action
            And yet another action
        Then some testable outcome is achived
            And something else we can check happend too
            
    Scenario: A different situation
    
Для Cucumber features, ключевыми словами, используемыми тут являются Feature, Scenario, Given, When, Then и And. Feature используется для определения тестируемой группы, когда публикуются результаты.

В настоящее время (2014 Feb 26) оператор Feature и его описательный блок текста не используется Cucumber за исключением идентификации (при публикации результатов) и документирования. Тем не менее, оператор Feature возможно содержит самую важную часть информации, содержащуюся в feature файле. Здесь это твой ответ на вопрос того почему эта работа ведется. И если у тебя нет очень хорошей, оправданной причины, которую можно ясно(четко) объяснить в нескольких предложениях, тогда тебе возможно не следует расходовать силы на это функциональное требование совсем. Прежде всего BDD должен иметь некоторе конкретное business value (бизнес требование), реализация которой поддается измерению до того как ты напишешь одну строчку кода. ( see popping the why? stack)

Как и в случае с Feature, Scenario используется только для определения(идентификации), когда публикуются ошибки и для документирования части работы. Предложения (steps) которые образуют сценарий (Scenario) каждый начинается с: Given, When, Then, And и But ( и иногда *). Все они ключевые слова Gherkin/Cucumber методы, которые принимают аргументы строки которые следуют после ключевых слов. Они являются steps, которые Cucumber будет публиковать при успешном, неудачном или ожидании выполнения основанный на результатах соответствующих step matcher-ах(сопоставителях) в файлах step_definitions.rb. Пять ключевых слов (и *) являются равноценными друг другу и полностью взаимозаменяемы.


        Что такое Step Definitions?

Строка следюущая за ключевым словом в feature файле является сравниваемой со всеми matchers(сопоставителями) содержащимися во всех загруженных файлах step_definitions.rb. Step definition очень похоже на это:

    Given /there are (\d+) froobles/ do |n|
      Frooble.transaction do
        Frooble.destroy_all
        n.to_i.times do |n|
          Frooble.create! :name => "Frooble #{n}"
        end
      end
    end

Важными элементами здесь являются метод (Given), принимающий в качестве аргументов regexp ограниченное / ( также заключенное в кавычки "single string" может использоваться вместо /) и этот matcher(сопоставитель) метод, за которым следует блок. Другими словами, написанный по-разному в Ruby этот matchar method мог бы выглядет следующим образом:

    Given( /there are (\d+) froobles/ ) { |n|
      ...
    }

Кроме того, это означает, что step definition method blocks получают в качестве своих аргументов строковые значения. Поэтому n.to_i.times и не просто n.times (но также взглянуть на Cucumber преобразования). Это также означает что за самими step matchers могу следовать специальные regexp модификаторы, такие как i, если вы хотите избежать проблем включающие преобразование в верхний регистр.

В feature примере представленном выше, имелось утверждение сценария: And some other action. Это могло бы соответствовать любому из следующих step definitin matchers если присутствовать в любом step_definion.rb файле, найденном в корневом каталоге features.

    Given /some other action/ do
    Then "some other action" do
    When /some other Action/i do
    When /some other (Action)/i do |action|
    Then /(\w+) other action/i do |prefix_phrase|
    Given /(\w+) other (\w+)/i do |first_word, second_word|
    But /(\w+) Other (.*)/i do |first_word, second_phrase|
    And /(.*) other (.*)/i do |first_phrase, second_phrase|
    
The step definition match(сопоставление) зависит только от шаблона, заданного как аргумент переданного в Given/When/Then метод и не от самого step method имени. Поэтому я выбрал практический подход только используя When /I have a match/ do в своих step definition файлах, т.к When имеет более естественный вид для меня, как matcher-а. Другие находят слово "Given" имеет более естественное чувство языка в этом контексе.

Если Cucumber находит больше одного matcher-а во всех step definitions файлах, тогда соответствующее утверждение сценария "возмущается" о том, что он нашел несколько step definition matches для этого step и вынуждает вас отличить их. Вы можете дать указания Cucumber просто выбрать один из кандидатов(вариантов) вместо передачи --guess опции в командной строке.

Как некоторые считают лучшая форма окружить(заключить) в двойные кавычки, " ", все элементы в feature step предложениях, которые означают, что они должны быть приняты как значения переменных переданных в step definition. Это просто соглашение. Тем не менее, если вы решили придерживаться этой дороги, тогда вы должны привести в соответствие все step definition matchers если символы " сейчас являются частью literal matcher string. Например:

Feature statement:

    Given some determinable "business" situation
    
step definition

    When /determinable "(.*)" situation/ do |s|
    
Под конец, у вас могут быть step definitions, которые вызывают другие step defintions, включая те, которые содержатся в других step definitions файлах. Это один из способов( не реккомендуется), с помощью которого вы можете указать процедурные детали, объединяя(смешивая) другие steps. Например:

    When /some "(.*)" action/ do |act|
      ...
    end
    
    When /in an invoiced non-shipped situation/ do
      step( "some \"invoiced\" acton" )
      step( "some \"non-shipped\" action" )
      ...
    end
    
    
