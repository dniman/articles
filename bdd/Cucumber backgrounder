    Cucumber Backgrounder
    Or: How I Lerned to Stop Worrying and Start Behaving
    
    Введение

Cucumber это инструмент, который осуществляет проектирование рабочего процесса на основе поведения(Behaviour Driven Design (BDD) workflow). Этот документ имеет дело в основном первоначальную настройку и первое использование Cucumber-Rails и Cucumber Rubygems. На это в качестве основы потребуется инфраструктура вэб приложения Ruby on Rails (RoR). Подробное обсуждение BDD, TDD и Panic Driven Development может быть найдене повсюдю. Конечно, существуют некоторые скептики по этой полной Agile материалу, но если вы читаете это, то вы возможно не являетесь одним из них.

Вы убедитесь что некоторое знакомство с Ruby языком является полезным и несколько меньше, знакомство с RoR инфраструктурой. Эта статья рассчитана на новичка и потому несколько длинная. Если вы знакомы с BDD/TDD идеями или являетесь опытным Rubist некоторые идею вам покажутся такими очевидными на вопрос их полезности. Остальные, в особенности те новички в Ruby, могут не иметь ваших преимуществ и этот материал предназначен для этих читателей.

С тех пор как появилась первоначальный вариант этой статьи, Cucumber подвергся повторяющимся исправлениям и рефакторингу. Среди всего этого было разумное решение перенести части зависимые от реализации в определенные(конкретные) программные инфраструктуры - в их собственные gems. В результате, установка Cucumber для инфраструктуры сейчас обычно начинается с установки определенной инфраструктуры Cucumber gem, который в свою очередь тянет за собой ядро Cucumber gem как зависимость. Cucumber предоставляет поддержку для широкого диапазона Ruby VMs, такие как JRuby, альтернативным программным инфраструктурам, такие как Sinatra, другие программные языки такие как Python, среды для тестирования, такие как Capybara и предоставляет поддержку языков i18n для feature and step файлов. Для получение некоторых из этих функциональных возможностей требуется установка дополнительных gems такие как cucumber-sinatra.

Подробности, относящиеся к установке Cucumber Rubygem и реккомендуемые инструменты необходимые для RoR находятся в wiki разделе под заголовком Ruby on Rails. Чтобы экспериментировать с Cucumber и Cucumber-Rails я реккомендую вам создать новый RoR проект и использовать имеющуюся по умолчанию SQLite3 базу данных. Оффициальное руководство Getting Started with Rails является подходящим введением в RoR.

Обратите внимание, что в этом документе я часто использую термины testing и test, где практикующие BDD предпочитают термины behaviour и expectation. Когда я использую слово test в BDD контексте, в действительности я говорю выражая и подтверждая ожидаемое поведение.

Читателям следует всегда считать, что информация содержащаяся здесь может быть не актуальна и таким образом быть неполной и ложной в некотором отношении. Тем не менее, любые такие неисправности будут как правило заключать детали конктретной реализации и не следует сильно принижать правильность всего доклада(выступления).Тем не менее, пожалуйста, примите к сведению везде где вы увидете код как script/generate blah в примерах и замечаниях ниже(далее), синтаксис Rails генератора изменился на rails g blah начиная с RoR v.3.0. Also bear in mind that with post RoR-2 projects bundle exec generally must preface most, if not all, of the command line examples given below.

    С чего начать?
    
Прежде чем приступить будьте уверены что вы правильно установили cucumber-rails в ваш RoR проект. Сейчас мы действительно можем приступить.

    Feature: Design and Build a Ruby on Rails web app using Behaviour Driven Development
    
    In order to reduce rework and produce a web app at low cost and high speed
    A developer
    Should employ a BDD methodology and agile tools
    
    
    Scenario: Cucumber should be installed and configured
    Given I have installed the gem named "rails"
      And I have installed the gem named "cucumber-rails"
      And I have generated a RoR project named "my_project"
      And the present working directory is the Rails root directory of "my_project"
      And I have the file cucumber.yml in the config directory of "my_project"
      And the file cucumber.yml contains a valid default profile
      
    When I run "rails g cucumber"
    
    Then I should create the directory ./features
      And I should create the file ./features/features.feature
      And I should create the directory ./features/step_definitions
      ...
      And I should create the file ./config/environments/environment/cucumber.rb
      And I should create the file ./config/cucumber.yml
      And I should modify ./config/database.yml
      ...
      
 Вышеизложенное является примером формы, которую feature файлы часто принимают(печально). Эти строки, называемые feature или scenario steps или утверждения, являются пользовательским интерфейсом для осуществления тестирования с Cucumber. То, что дано выше написано в повелительном стиле просто для наглядных целей. Никогда не кладите то, что выглядит таким образом в feature file (но вы будете). На практике, все эти Then/And утверждения следует отнести к одному простому утверждению в декларативном стиле. Например, I should create the Cucumber environment. Беспорядочные детали просто того, что должно заключать в себе Cucumber среда размещается в step definition файлах.
 
Вместо этого, feature должен выглядеть следующим образом:

    Feature: Design and Build a Ruby on Rails web app using Behaviour Driven Development
    
    In order to produce a web app at low cost and high speed
    A developer
    Should employ Ruby on Rails with Cucumber BDD tools
    
    Scenario: Cucumber-Rails should be installed and configured
        Given I am in a rails project root
            And I have installed cucumber-rails
            And I do not have a cucumber environment
        When I run the cucumber-rails generator
        Then I should have a cucumber environment
        

      
 


    Что такое Features и Scenarious?

Feature можно представить как неделимую единицу функциональной возможности встроенной в проект, к которому она принадлежит. Например, задача аудентификации и реакция пользовательского интерфейса как правило считается функциональной возможностью, в то время как полная система идентификации обязательно заключает в себе массу функциональных возможностей. Отдельная функциональная возможность (Feature) как правило содержится в своем собственном файле (оканчивающийся на .feature). Каждая функциональная возможность (Feature) как правило определяет (детализирует) хотя бы несколько сценариев (Scenarious).
    
Scenario является блоком утверждений внутри feature файла, который описывает некоторое желаемое или не реккомендуемое(запрещенное) поведение. Для требуемых ответов сценарий (scenario) может проверять предоставляемые
интерфейсом логина поля ввода, неудачные попытки логируются или же о них сообщается пользователю, id которого является заблокированным после нескольких неудачных попыток и так далее. Каждый сценарий выполняет код реализации чтобы удостовериться в том, что для каждого предполагаемого условия в самом деле происходит ожидаемое поведение. Напомним что эти сценарии указывают Что (What) и следует избегать ответа на вопрос: Как?(How)

Каждый сценарий состоит из трех классов утверждений, Given, When и Then, которые эффективно разделяют каждый сценарий на три стадии(stage). Каждый стадия сценария состоит из одного или более утверждений, которые используются чтобы соответствовать, чтобы проверять step definitions. Общепринятым оформлением является :


    Feature: Some terse yet descriptive text of what is desired (Отчасти краткий, но описательный текст того, что желательно
    
    In order that some business value is realized ( Для того чтобы реализовать бизнес требование)
    An actor with some explicit system role ( действующему лицу с некотороя явной системной ролью)
    Should obtain some beneficial outcome which furthers the goal ( следует получить некоторые полезные результаты, которые способствуют достижению цели )
    To Increase Revenue | Reduce Costs | Protect Revenue (pick one) ( для увеличения доходов | снижение издержек | защиты доходов (выберите один) )
    
    Scenario: Some determinable business situation
        Given some condition to meet
            And some other condition to meet
        When some action by the actor
            And some other action
            And yet another action
        Then some testable outcome is achived
            And something else we can check happend too
            
    Scenario: A different situation
    
Для Cucumber features, ключевыми словами, используемыми тут являются Feature, Scenario, Given, When, Then и And. Feature используется для определения тестируемой группы, когда публикуются результаты.

В настоящее время (2014 Feb 26) оператор Feature и его описательный блок текста не используется Cucumber за исключением идентификации (при публикации результатов) и документирования. Тем не менее, оператор Feature возможно содержит самую важную часть информации, содержащуюся в feature файле. Здесь это твой ответ на вопрос того почему эта работа ведется. И если у тебя нет очень хорошей, оправданной причины, которую можно ясно(четко) объяснить в нескольких предложениях, тогда тебе возможно не следует расходовать силы на это функциональное требование совсем. Прежде всего BDD должен иметь некоторе конкретное business value (бизнес требование), реализация которой поддается измерению до того как ты напишешь одну строчку кода. ( see popping the why? stack)

Как и в случае с Feature, Scenario используется только для определения(идентификации), когда публикуются ошибки и для документирования части работы. Предложения (steps) которые образуют сценарий (Scenario) каждый начинается с: Given, When, Then, And и But ( и иногда *). Все они ключевые слова Gherkin/Cucumber методы, которые принимают аргументы строки которые следуют после ключевых слов. Они являются steps, которые Cucumber будет публиковать при успешном, неудачном или ожидании выполнения основанный на результатах соответствующих step matcher-ах(сопоставителях) в файлах step_definitions.rb. Пять ключевых слов (и *) являются равноценными друг другу и полностью взаимозаменяемы.


        Что такое Step Definitions?

Строка следюущая за ключевым словом в feature файле является сравниваемой со всеми matchers(сопоставителями) содержащимися во всех загруженных файлах step_definitions.rb. Step definition очень похоже на это:

    Given /there are (\d+) froobles/ do |n|
      Frooble.transaction do
        Frooble.destroy_all
        n.to_i.times do |n|
          Frooble.create! :name => "Frooble #{n}"
        end
      end
    end

Важными элементами здесь являются метод (Given), принимающий в качестве аргументов regexp ограниченное / ( также заключенное в кавычки "single string" может использоваться вместо /) и этот matcher(сопоставитель) метод, за которым следует блок. Другими словами, написанный по-разному в Ruby этот matchar method мог бы выглядет следующим образом:

    Given( /there are (\d+) froobles/ ) { |n|
      ...
    }

Кроме того, это означает, что step definition method blocks получают в качестве своих аргументов строковые значения. Поэтому n.to_i.times и не просто n.times (но также взглянуть на Cucumber преобразования). Это также означает что за самими step matchers могу следовать специальные regexp модификаторы, такие как i, если вы хотите избежать проблем включающие преобразование в верхний регистр.

В feature примере представленном выше, имелось утверждение сценария: And some other action. Это могло бы соответствовать любому из следующих step definitin matchers если присутствовать в любом step_definion.rb файле, найденном в корневом каталоге features.

    Given /some other action/ do
    Then "some other action" do
    When /some other Action/i do
    When /some other (Action)/i do |action|
    Then /(\w+) other action/i do |prefix_phrase|
    Given /(\w+) other (\w+)/i do |first_word, second_word|
    But /(\w+) Other (.*)/i do |first_word, second_phrase|
    And /(.*) other (.*)/i do |first_phrase, second_phrase|
    
The step definition match(сопоставление) зависит только от шаблона, заданного как аргумент переданного в Given/When/Then метод и не от самого step method имени. Поэтому я выбрал практический подход только используя When /I have a match/ do в своих step definition файлах, т.к When имеет более естественный вид для меня, как matcher-а. Другие находят слово "Given" имеет более естественное чувство языка в этом контексе.

Если Cucumber находит больше одного matcher-а во всех step definitions файлах, тогда соответствующее утверждение сценария "возмущается" о том, что он нашел несколько step definition matches для этого step и вынуждает вас отличить их. Вы можете дать указания Cucumber просто выбрать один из кандидатов(вариантов) вместо передачи --guess опции в командной строке.

Как некоторые считают лучшая форма окружить(заключить) в двойные кавычки, " ", все элементы в feature step предложениях, которые означают, что они должны быть приняты как значения переменных переданных в step definition. Это просто соглашение. Тем не менее, если вы решили придерживаться этой дороги, тогда вы должны привести в соответствие все step definition matchers если символы " сейчас являются частью literal matcher string. Например:

Feature statement:

    Given some determinable "business" situation
    
step definition

    When /determinable "(.*)" situation/ do |s|
    
Под конец, у вас могут быть step definitions, которые вызывают другие step defintions, включая те, которые содержатся в других step definitions файлах. Это один из способов( не реккомендуется), с помощью которого вы можете указать процедурные детали, объединяя(смешивая) другие steps. Например:

    When /some "(.*)" action/ do |act|
      ...
    end
    
    When /in an invoiced non-shipped situation/ do
      step( "some \"invoiced\" acton" )
      step( "some \"non-shipped\" action" )
      ...
    end
    
    
